#include "Window.h"

#define WIN_NUM_BUF_SIZE 12

wimp_t task;
wimp_event_no event;
wimp_block *block;
osbool QUIT = FALSE;
osbool more;
osbool windowOpen;
wimp_window *window;
wimp_window_state state;
wimp_w winHandle;
wimp_caret caret;
int context = 0;
int used, data_used;
char *data;

osspriteop_area *area;
os_factors factors;
int size;

FILE *logFile;

//********** SCREEN MODE INFO **********
typedef union
{        
   int numbers[14];

   struct
   {    
      int modeFlags,
          scrRCol,
          scrBRow,
          nColour,
          xEigFactor,
          yEigFactor,
          lineLength,  
          screenSize,
          yShiftSize,
          log2bpp,
          log2bpc,
          xWindLimit,
          yWindLimit,
          minScreenBanks;
   }
   info;
}
ModeInfo;                                 

ModeInfo modeInfo;
         
void updateModeInfo()
{                                      
   for (int i = 0; i < 15; i++)
   {
      modeInfo.numbers[i] = i;
   }

   modeInfo.numbers[14] = -1;

   os_error *e = xos_read_vdu_variables(
					(os_vdu_var_list*)modeInfo.numbers, 
                    modeInfo.numbers
				);
}

//********** KEYBOARD HANDLER **********
const float gravity = -0.5;
int isJumping = 0;

void handleKey(Sprite *mario)
{
	int leftAr = 25;
	int leftArPressed;
	int rightAr = 121;
	int rightArPressed;
	int xKey = 66;
	int xKeyPressed;
	int keyPressed = 0;
	
	os_byte(
		osbyte_SCAN_KEYBOARD,
		leftAr ^ 0x80,
		NULL,
		&leftArPressed,
		NULL
	);
	
	os_byte(
		osbyte_SCAN_KEYBOARD,
		rightAr ^ 0x80,
		NULL,
		&rightArPressed,
		NULL
	);
	
	os_byte(
		osbyte_SCAN_KEYBOARD,
		xKey ^ 0x80,
		NULL,
		&xKeyPressed,
		NULL
	);
	
	//Left arrow - move left
	if (leftArPressed)
	{
		mario->x -= mario->xSpeed;
		if (mario->facing == 'R')
		{
			osspriteop_flip_about_yaxis(osspriteop_USER_AREA, area, (osspriteop_id) "mario0");
			osspriteop_flip_about_yaxis(osspriteop_USER_AREA, area, (osspriteop_id) "mario1");
			osspriteop_flip_about_yaxis(osspriteop_USER_AREA, area, (osspriteop_id) "mario2");
			osspriteop_flip_about_yaxis(osspriteop_USER_AREA, area, (osspriteop_id) "mario3");
			osspriteop_flip_about_yaxis(osspriteop_USER_AREA, area, (osspriteop_id) "mariojump");
			mario->facing = 'L';
		}
		keyPressed = 1;
	}
		
	//Right arrow - move right
	if (rightArPressed)
	{
		mario->x += mario->xSpeed;
		if (mario->facing == 'L')
		{
			osspriteop_flip_about_yaxis(osspriteop_USER_AREA, area, (osspriteop_id) "mario0");
			osspriteop_flip_about_yaxis(osspriteop_USER_AREA, area, (osspriteop_id) "mario1");
			osspriteop_flip_about_yaxis(osspriteop_USER_AREA, area, (osspriteop_id) "mario2");
			osspriteop_flip_about_yaxis(osspriteop_USER_AREA, area, (osspriteop_id) "mario3");
			osspriteop_flip_about_yaxis(osspriteop_USER_AREA, area, (osspriteop_id) "mariojump");
			mario->facing = 'R';
		}
		keyPressed = 1;
	}
			
	//X - jump
	if (xKeyPressed && !isJumping)
	{
		mario->ySpeed = 12.0;
		keyPressed = 1;
		isJumping = 1;
		mario->curFrame = mario->frameJump;
	}
	
	if (isJumping)
	{
		mario->y += mario->ySpeed;
		mario->ySpeed += gravity;
	}
	
	//Update animation if key pressed, reset animation if not
	if (keyPressed)
	{
		mario->frame++;
		
		if (mario->frame%2 == 0)
		{
			if (mario->curFrame == mario->frame1)
				mario->curFrame = mario->frame2;
			else if (mario->curFrame == mario->frame2)
				mario->curFrame = mario->frame3;
			else if (mario->curFrame == mario->frame3)
				mario->curFrame = mario->frame4;
			else if (mario->curFrame == mario->frame4)
				mario->curFrame = mario->frame1;
		}
	}
	else if (! isJumping)
	{
		mario->curFrame = mario->frame1;
	}
	
	//Bounds - uses width, height and scaling factor
		//NOTE: for some reason using scale factor 4 in the bound collisions works, despite
		//using scale factor 2 with the sprites. X bound seems exact, Y bound slightly off
	if (mario->x < 0)
		mario->x = 0;
	else if ((mario->x + 16 * 4) > 1024)
		mario->x = (1024 - 16 * 4);
	if (mario->y < 0)
	{
		isJumping = 0;
		mario->y = 0;
		mario->curFrame = mario->frame1;
	}
	else if ((mario->y + 24 * 4) > 960)
		mario->y = (960 - 24 * 4);
	
}

//********** ANIMATION TIMER **********

os_t timer;
void (*timerCallback)(void*);
void *timerWorkspace;

void initialiseTimer()
{
	timer = 0;
	timerCallback = NULL;
	timerWorkspace = NULL;
}

void setTimer(int cs, void (*callback)(void*), void *ws)
{
	timer = os_read_monotonic_time() + cs;
	timerCallback = callback;
	timerWorkspace = ws;
}

void updateTimer()
{
	if (timer > 0)
	{
		os_t time = os_read_monotonic_time();
		
		if (time >= timer)
		{
			timer = 0;
			timerCallback(timerWorkspace); 
		}
	}
}

void updateGame(void *ws)
{
	Sprite* sprite = (Sprite*)ws;
	
	//Get keyboard input and update player sprite if necessary
	handleKey(sprite);
	
	wimp_force_redraw(block->open.w, 0, 0, 1024, +960);
	setTimer(4, updateGame, ws);
}



//********** MAIN FUNCTION **********

int main()
{
	windowOpen = FALSE;
	logFile = fopen("<MarioBros$Dir>.Log", "w");
	task = wimp_initialise(wimp_VERSION_RO3, "Pong", NULL, NULL);
	updateModeInfo();
	
	//Load sprites
	area = loadSpriteFile("<MarioBros$Dir>.mario", &size, logFile);
	Sprite mario;
	mario.x = 100;
	mario.y = 100;
	mario.xSpeed = 7;
	mario.ySpeed = 0;
	selectSprite(
		&mario, 
		"mario",
		2,
		area, 
		size,
		&factors,
		modeInfo.info.xEigFactor,
		modeInfo.info.yEigFactor,
		logFile
	);
	
	//Load window
	wimp_open_template("<MarioBros$Dir>.Templates");
	wimp_load_template(wimp_GET_SIZE, NULL, NULL, wimp_NO_FONTS, "Main", context, &used, &data_used);
	data = malloc(data_used);
	window = malloc(used);
	wimp_load_template(window, data, (char const *) data + data_used, wimp_NO_FONTS, "Main", context, NULL, NULL);
	wimp_close_template();
	block = (wimp_block*)malloc(sizeof(wimp_block));
	loadWindowIntoBlock(&window, &block);
	winHandle          = block->open.w;
	addIconToBar();
	xwimp_open_window(&block->open);
	xwimp_get_caret_position(&(block->caret));
	xwimp_set_caret_position(
		winHandle,
		-1,
		-1,
		-1,
		-1,
		block->caret.index
	);
	
	// Set timer
	initialiseTimer();
	setTimer(64, updateGame, (void*)&mario);
	
	//*** MAIN LOOP ***
	while (!QUIT)
	{
		//*** WIMP POLL ***
		event = wimp_poll(wimp_QUEUE_KEY, block, NULL);
		switch(event)
		{
			case wimp_NULL_REASON_CODE:
				updateTimer();
				break;
			case wimp_REDRAW_WINDOW_REQUEST:
				redrawWindow(block, area, &mario, &factors, logFile);
				break;
			case wimp_MOUSE_CLICK:
				fprintf(logFile, "mouse click\n");
				fflush(logFile);
				break;
			case wimp_OPEN_WINDOW_REQUEST:
				wimp_open_window(&block->open);
				windowOpen = TRUE;
				break;
			case wimp_CLOSE_WINDOW_REQUEST:
				wimp_close_window(block->close.w);
				QUIT = TRUE;
				break;
			case wimp_USER_MESSAGE:
			case wimp_USER_MESSAGE_RECORDED:
				QUIT = TRUE;
				break;
		}
	}

	fclose(logFile);
	free(window);
	wimp_close_down(task);
	return 0;
}